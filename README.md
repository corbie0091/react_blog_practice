우리가 왜 설치 했는가

리액트 설치

직접 수동으로 리액트 라이브러리 설치해도 되지만 ..

앱은
Create React App 라이브러리로 만드는게 유리

npm을 설치해야함 - 근데 이건 nodejs설치하면 자동으로 됨

쉽게 명령어로 다운로드가 가능

--프로젝트안에 들어있는 폴더들의 특징--

node_modules 폴더 : 구동에 필요한 라이브러리 소스코드보관함

publick : html 이미지 파일등 static파일들 모아놓는 곳

src: 코드 짜는곳(소스코드 보관함)

app.js가 메인페이지가 될 것.

보통 웹페이지는 html파일로 되어 있어야하는데
js파일로도 웹페이지를 잘 띄워줌

그이유는 App.js파일을 index.html로 잘들어가게끔
index.js파일이 도와주기 때문

package.json: 프로젝트 정보들이 포함ㅇ(이름, 버전)

- 라이브러리정보들까지 포함되어 있음

2강 :
자바스크립트 파일에서 JSX라는 언어로 html대용품으로서 구현이 가능해짐

즉 리액트에서 div같은 걸 만드려면 createElement같은걸썻어야햇음 그래서 JSX로 표현하게됨
ex) JSX = <div></div>

JSX 문법

1. div등의 태그에 class넣을떈 className
   (참고)css파일 쓰려면 상단에서 import 'css경로 잘 둬야함
2. 변수 넣을땐 {중괄호} - 데이터바인딩

생 자바스크립트면
document.querySelector('h4').innerHTML = post;
이렇게 해서 변수에 집어 넣을 수 있지만 리액트는 이런과정이 필요가 없음
그냥 {}안에 변수명을 적어주면 그 변수가 들어가짐 id속성같은데도 {}가능

3. style 넣을 떈 style={{스타일명: '값'}}이렇게 가능
<h4 style={{color: 'red'}}></h4>
그리고 font-size라고 하면 -를 마이너스로 인식하기에 fontSize이런식으로 해줘야함

css파일열기 귀찮으면 이렇게 간단히도 설정가능

3강주의점:
return()안에는 <div>태그 2개이상 병렬로하면 오류뜸

#[memo1 ./App.js]
// 자료 잠깐 저장할 땐 변수사용

// 리액트에선 state문법을 사용하는 경우가 o
// 1.import { useState }
// 2.useState(보관할 자료)
// 3.let[작명, 작명]
// a는 state에 보관했던 자료가 나옴 = 변수와 똑같이 사용가능
// b는 state 변경을 도와주는 함수임
// let [a, b] = useState("남자 코트 추천");
// let [글제목, b] = useState("남자 코트 추천");

let num = [1, 2, 3];
// 근데 1과 2가 너무 유용해서 변수로 따로 뺴고싶음
// 그럴때 Destructuring문법을 사용함
let a = num[0]; //1
let c = num[1]; //2

// 이렇게 말고 편하게 뽑아 쓸 수 있는 문법이 있음
let [d, e] = [1, 2]; // d =1 , e = 2
// let [a, b] = useState("남자 코트 추천");
// 즉, 이부분도 ㄴ [남자코트추천, 함수] 이렇게 남는다는 것임

// state문법은 언제 쓸까??
// 변수 문법이 있는데 왜 굳이??
// 차이점: 변수 문법에서 갑자기 데이터변수가 변경되면
// html이 바뀌어야하는데 자동으로 되지 않음
// 변경이 되었으니 변수도 바꿔줘라가 안된다는 것임
// 그래서 state문법에서는 그렇게 바뀌면 재렌더링이 되는 것임
// 그래서 html전체가 "자동으로 재랜더링이 된다"는 것임
// 그래서 state문법을 쓰는 것임

let [logo, setLogo] = useState("ReactBlog");
//ㄴ 복습은 좋은데 굳이 바뀌지 않는 데이터이므로 쓰지 않아도 됨
// 즉 state문법을 적절히 쓰는 것이 좋음
// 자주 변경될 거 같은 제목, 날짜 클래스명 등 이런것들을 state로 빼서 미리 저장
// 이후 state를 데이터바인딩하는 식으로 코딩해주면 된다.

#[memo2 ./App.js]
// 글제목[0] = "여자 옷 추천"; // 영구적으로 수정해버림
// 그래서 array/object 다룰때 원본은 보존하는 게 좋음
// copy문법: copy로 가져오고 거기서 [0]부분을 수정
// 그것으로 글제목을 대체하는 방식
// [...글제목] : ...은 스프레드 연산자로서 다 보여줄 수 있음

// [동작원리파악1]
// state변경함수의 특징
// 기존 state == 신규 state의 경우 안바꿔줌
// 글제목 == copy 이런식으로
// Q. let copy = 글제목일땐 안됐는데.. 왜?
// why? 에너지 절약임 . 굳이 바꿀필요가 없으면 안바꿈
// [동작원리파악2]
// 리액트에서의 array/object특징: reference data type이라서..
// let arr = [1,2,3];
// 이 것은 RAM의 미지의 공간에 저장해놓고 1,2,3변수에는 그 화살표만 저장됨
// ex) 글제목[0] = '여자 코드 추천' 이런식으로 코드를 짜면
// let 글제목에서 [남자코트추천, ,,] 에서 [여자코트추천, ,,]이런식으로 바뀌긴함 근데,
// array를 수정했지 변수에 있던 화살표는 수정이 안됨
// 그리고 동작원리파악1에 의해서 글제목 에서 바뀐게 글제목 이런식으로 집어 넣으면
// 기존 state와 신규가 같기 때문에 수정버튼을 눌러도 변경이 되지 않음
// 글제목에 저장되어 있던건 화살표 밖에 없음
// 그래서 copy에 똑같은 화살표를 복사함
// 변수1번과 2번이 화살표가 같으면 변수1 변수2 비교해도 true가 나옴
// 즉 console.log(copy == 글제목) => true로 출력이됨
// 기존 state와 신규 state가 같다고 되기 떄문에 state변경이 안됨
// 이부분에 대한 해법 : [... ] 을 이용
// : 화살표를 새로 바꿔주고 괄호를 벗겨주세요 라는 뜻임 (즉 새로운 state)
// 그래서 수정버튼을 누르면 state변경이 쉽게 됨
// 정리: 1. 기존 state가 array나 object이다? = 독립적 카피본을 만들어서 수정해야함
// 2. 별개의 복사본을 만들어 그것을 set함수에 집어 넣으면 된다.

#[memo3]
// 컴포넌트 문법
// 더러운 html을 <Modal></Modal> 이런식으로 함
// 미래의 나, 다른 사람들이 이해하기 쉬움
// 컴포넌트 만드는 법
// function 만들고
// return()안에 html 담기
// <함수명></함수명>쓰기

#[memo4]
// 다른 function 바깥에 만들어야함
// 담을 내용들을 return ()안에 담고
// [참고] <div></div> <div></div>이런식으로 병렬은 x 병렬기입하고 싶으면 <div><div>해야함
// 근데 의미없는 <div>사용보단 <></> 라는 fragment문법을 사용하면 된다
// 한단어로 축약한 컴포넌트 ( Modal )을 html태그형식으로 사용하면 됨

// 컴포넌트 만들어 쓰면 좋은 점 :
// 1. 반복적인 html을 축약할 때(코드가 짧아짐)
// 2. 큰 페이지 전환에 유리(큰페이지 만들때 사용)
// 3. 자주 변경되는 html UI같은걸 컴포넌트로하면 성능상 유리

#[memo5]
// 변수를 만들고 함수를 하나 집어 넣어주세요 (이것도 됨 - 이것도 그냥 컴포넌트)
let Modal = () => {}

// let 으로 만들 수도 있고 const도 만들 수 있음
// const로 만들어 놓으면 나중에 실수로 변수정보를 변경시에 에러체크가 가능

# memo6

// 컴포넌트의 단점 // 여기에 state넣고 싶은데.. 어떻게 해야해 // 즉 state
가져다 쓸때 문제 생김 // A함수에 있던 변수는 B함수에서 맘대로 가져다 쓸 수없음
// 그래서 모든걸 다 이렇게 컴포넌트로 만들지 말자.
